"""
Main FastAPI application for OCR service
Handles receipt image upload and text extraction
"""
from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
from typing import Optional

from .models import OCRResponse, ErrorResponse
from .ocr_engine import OCREngine
from .image_processor import ImageProcessor
from .parser import ReceiptParser

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="SmartBill OCR API",
    description="AI-powered receipt OCR service for expense splitting",
    version="1.0.0"
)

# Add CORS middleware to allow frontend requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize OCR engine globally (loaded once at startup)
ocr_engine: Optional[OCREngine] = None

@app.on_event("startup")
async def startup_event():
    """
    Initialize OCR engine on application startup
    """
    global ocr_engine
    logger.info("Starting OCR service...")
    ocr_engine = OCREngine()
    logger.info("OCR service ready")

@app.get("/")
def root():
    """
    Health check endpoint
    """
    return {
        "service": "SmartBill OCR API",
        "status": "running",
        "version": "1.0.0"
    }

@app.get("/health")
def health_check():
    """
    Detailed health check
    """
    return {
        "status": "healthy",
        "ocr_engine": "initialized" if ocr_engine else "not_initialized"
    }

@app.post("/api/ocr/upload", response_model=OCRResponse)
async def upload_receipt(image: UploadFile = File(...)):
    """
    Upload and process a receipt image
    
    Args:
        image: Receipt image file (JPEG, PNG, etc.)
        
    Returns:
        OCRResponse with extracted items and metadata
        
    Raises:
        HTTPException: If processing fails
    """
    # Validate file type
    if not image.content_type.startswith('image/'):
        raise HTTPException(
            status_code=400,
            detail="File must be an image (JPEG, PNG, etc.)"
        )
    
    try:
        logger.info(f"Processing receipt: {image.filename}")
        
        # Read image bytes
        image_bytes = await image.read()
        
        # Preprocess image
        logger.info("Preprocessing image...")
        processed_image = ImageProcessor.preprocess(image_bytes)
        
        # Extract text using OCR
        logger.info("Running OCR...")
        raw_text = ocr_engine.extract_text(processed_image)
        
        if not raw_text:
            return OCRResponse(
                success=False,
                raw_text="",
                items=[],
                total=None,
                store_name=None
            )
        
        # Parse text into structured data
        logger.info("Parsing receipt data...")
        items, total, store_name = ReceiptParser.parse(raw_text)
        
        logger.info(f"Successfully extracted {len(items)} items")
        
        return OCRResponse(
            success=True,
            raw_text=raw_text,
            items=items,
            total=total,
            store_name=store_name
        )
        
    except Exception as e:
        logger.error(f"OCR processing failed: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to process receipt: {str(e)}"
        )

@app.post("/api/ocr/test", response_model=OCRResponse)
async def test_ocr(text: str):
    """
    Test endpoint: Parse text directly without OCR
    Useful for testing parser without uploading images
    
    Args:
        text: Raw receipt text
        
    Returns:
        OCRResponse with parsed data
    """
    try:
        items, total, store_name = ReceiptParser.parse(text)
        
        return OCRResponse(
            success=True,
            raw_text=text,
            items=items,
            total=total,
            store_name=store_name
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to parse text: {str(e)}"
        )

# Error handler
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """
    Global exception handler for unexpected errors
    """
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            success=False,
            error="An unexpected error occurred"
        ).dict()
    )