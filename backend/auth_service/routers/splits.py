"""
Expense Split Routes
"""
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
import uuid as uuid_lib
import json
from datetime import datetime
from decimal import Decimal

from dependencies import get_db, get_current_user, SessionLocal
from models import User, Expense, ExpenseSplit
from split_schemas import (
    CreateExpenseSplitRequest,
    ExpenseSplitResponse,
    ExpenseSplitListResponse,
    SendBillRequest,
    SendBillResponse
)
from schemas import MessageResponse
from email_service import send_split_bill_email

router = APIRouter()

@router.post("/{expense_id}/splits", response_model=MessageResponse)
async def create_expense_splits(
    expense_id: str,
    request: CreateExpenseSplitRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Create expense splits for an expense
    """
    try:
        expense_uuid = uuid_lib.UUID(expense_id)
    except (ValueError, TypeError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid ID format"
        )
    
    # Verify expense ownership
    expense = db.query(Expense).filter(
        Expense.id == expense_uuid,
        Expense.user_id == current_user.id
    ).first()
    
    if not expense:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Expense not found"
        )
    
    # Create splits
    for participant in request.participants:
        # If contact_id provided, get email
        participant_email = participant.email
        contact_id = None
        
        if participant.contact_id:
            try:
                contact_uuid = uuid_lib.UUID(participant.contact_id)
                contact = db.query(Contact).filter(
                    Contact.id == contact_uuid,
                    Contact.user_id == current_user.id
                ).first()
                if contact:
                    friend = db.query(User).filter(User.id == contact.friend_user_id).first()
                    if friend:
                        participant_email = friend.email
                        contact_id = contact_uuid
            except (ValueError, TypeError):
                pass
        
        split = ExpenseSplit(
            expense_id=expense_uuid,
            participant_name=participant.name,
            participant_email=participant_email,
            contact_id=contact_id,
            amount_owed=Decimal(str(participant.amount_owed)),
            items_detail=json.dumps(participant.items_detail) if participant.items_detail else None
        )
        db.add(split)
    
    db.commit()
    
    return MessageResponse(message="Expense splits created successfully")


@router.get("/{expense_id}/splits", response_model=ExpenseSplitListResponse)
async def get_expense_splits(
    expense_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get expense splits for an expense
    """
    try:
        expense_uuid = uuid_lib.UUID(expense_id)
    except (ValueError, TypeError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid ID format"
        )
    
    # Verify expense ownership
    expense = db.query(Expense).filter(
        Expense.id == expense_uuid,
        Expense.user_id == current_user.id
    ).first()
    
    if not expense:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Expense not found"
        )
    
    # Get splits
    splits = db.query(ExpenseSplit).filter(ExpenseSplit.expense_id == expense_uuid).all()
    
    split_responses = []
    for split in splits:
        split_responses.append(ExpenseSplitResponse(
            id=str(split.id),
            expense_id=str(split.expense_id),
            participant_name=split.participant_name,
            participant_email=split.participant_email,
            contact_id=str(split.contact_id) if split.contact_id else None,
            amount_owed=split.amount_owed,
            items_detail=split.items_detail,
            is_paid=split.is_paid,
            email_sent=split.email_sent,
            email_sent_at=split.email_sent_at,
            created_at=split.created_at
        ))
    
    return ExpenseSplitListResponse(splits=split_responses, total=len(split_responses))


async def process_bill_sending_task(
    expense_uuid: uuid_lib.UUID,
    participant_ids: list[str],
    payer_email: str,
    payer_name: str
):
    """
    Background task to send bill emails
    """
    db = SessionLocal()
    try:
        # Fetch expense data (need fresh query as session is new)
        expense = db.query(Expense).filter(Expense.id == expense_uuid).first()
        if not expense:
            print(f"Expense {expense_uuid} not found in background task")
            return

        expense_data = {
            'store_name': expense.store_name or "Unknown",
            'total': expense.total_amount,
            'date': expense.created_at.strftime("%B %d, %Y") if expense.created_at else "Recent"
        }

        for split_id_str in participant_ids:
            try:
                split_id = uuid_lib.UUID(split_id_str)
                split = db.query(ExpenseSplit).filter(
                    ExpenseSplit.id == split_id,
                    ExpenseSplit.expense_id == expense_uuid
                ).first()
                
                if not split or not split.participant_email:
                    continue
                
                # Prepare split data
                items_detail = json.loads(split.items_detail) if split.items_detail else []
                split_data = {
                    'amount_owed': split.amount_owed,
                    'items_detail': items_detail
                }
                
                # Send email
                success = await send_split_bill_email(
                    to_email=split.participant_email,
                    to_name=split.participant_name,
                    payer_name=payer_name,
                    expense_data=expense_data,
                    split_data=split_data
                )
                
                if success:
                    # Update split record
                    split.email_sent = True
                    split.email_sent_at = datetime.utcnow()
                    db.commit()
                    
            except Exception as e:
                print(f"Error sending email to participant {split_id_str}: {e}")
                
    except Exception as e:
        print(f"Error in background bill sending task: {e}")
    finally:
        db.close()


@router.post("/{expense_id}/send-bills", response_model=SendBillResponse)
async def send_bills_to_participants(
    expense_id: str,
    request: SendBillRequest,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Send bill emails to selected participants
    """
    try:
        expense_uuid = uuid_lib.UUID(expense_id)
    except (ValueError, TypeError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid ID format"
        )
    
    # Verify expense ownership
    expense = db.query(Expense).filter(
        Expense.id == expense_uuid,
        Expense.user_id == current_user.id
    ).first()
    
    if not expense:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Expense not found"
        )
    
    # Get payer (user) info
    payer = current_user
    payer_name = payer.email.split('@')[0] if payer else "Your friend"
    
    # Add to background tasks
    background_tasks.add_task(
        process_bill_sending_task,
        expense_uuid,
        request.participant_ids,
        current_user.email,
        payer_name
    )
    
    # Return immediate response
    return SendBillResponse(
        sent_count=0,
        failed_count=0,
        results=[{
            "participant_id": "all",
            "participant_name": "all",
            "status": "queued",
            "message": "Emails are being sent in the background"
        }]
    )

